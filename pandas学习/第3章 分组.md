
# 第3章 分组

仅逐条程序过了一下，后面把练习补上



```python
import numpy as np
import pandas as pd
df = pd.read_csv('data/table.csv',index_col='ID')
df.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Class</th>
      <th>Gender</th>
      <th>Address</th>
      <th>Height</th>
      <th>Weight</th>
      <th>Math</th>
      <th>Physics</th>
    </tr>
    <tr>
      <th>ID</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1101</th>
      <td>S_1</td>
      <td>C_1</td>
      <td>M</td>
      <td>street_1</td>
      <td>173</td>
      <td>63</td>
      <td>34.0</td>
      <td>A+</td>
    </tr>
    <tr>
      <th>1102</th>
      <td>S_1</td>
      <td>C_1</td>
      <td>F</td>
      <td>street_2</td>
      <td>192</td>
      <td>73</td>
      <td>32.5</td>
      <td>B+</td>
    </tr>
    <tr>
      <th>1103</th>
      <td>S_1</td>
      <td>C_1</td>
      <td>M</td>
      <td>street_2</td>
      <td>186</td>
      <td>82</td>
      <td>87.2</td>
      <td>B+</td>
    </tr>
    <tr>
      <th>1104</th>
      <td>S_1</td>
      <td>C_1</td>
      <td>F</td>
      <td>street_2</td>
      <td>167</td>
      <td>81</td>
      <td>80.4</td>
      <td>B-</td>
    </tr>
    <tr>
      <th>1105</th>
      <td>S_1</td>
      <td>C_1</td>
      <td>F</td>
      <td>street_4</td>
      <td>159</td>
      <td>64</td>
      <td>84.8</td>
      <td>B+</td>
    </tr>
  </tbody>
</table>
</div>



## 一、SAC过程
### 1. 内涵
#### SAC指的是分组操作中的split-apply-combine过程
#### 其中split指基于某一些规则，将数据拆成若干组，apply是指对每一组独立地使用函数，combine指将每一组的结果组合成某一类数据结构
### 2. apply过程
#### 在该过程中，我们实际往往会遇到四类问题：
#### 整合（Aggregation）——即分组计算统计量（如求均值、求每组元素个数）
#### 变换（Transformation）——即分组对每个单元的数据进行操作（如元素标准化）
#### 过滤（Filtration）——即按照某些规则筛选出一些组（如选出组内某一指标小于50的组）
#### 综合问题——即前面提及的三种问题的混合
## 二、groupby函数
### 1. 分组函数的基本内容：
#### （a）根据某一列分组


```python
grouped_single = df.groupby('School')
```

#### 经过groupby后会生成一个groupby对象，该对象本身不会返回任何东西，只有当相应的方法被调用才会起作用
#### 例如取出某一个组：


```python
grouped_single.get_group('S_1').head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Class</th>
      <th>Gender</th>
      <th>Address</th>
      <th>Height</th>
      <th>Weight</th>
      <th>Math</th>
      <th>Physics</th>
    </tr>
    <tr>
      <th>ID</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1101</th>
      <td>S_1</td>
      <td>C_1</td>
      <td>M</td>
      <td>street_1</td>
      <td>173</td>
      <td>63</td>
      <td>34.0</td>
      <td>A+</td>
    </tr>
    <tr>
      <th>1102</th>
      <td>S_1</td>
      <td>C_1</td>
      <td>F</td>
      <td>street_2</td>
      <td>192</td>
      <td>73</td>
      <td>32.5</td>
      <td>B+</td>
    </tr>
    <tr>
      <th>1103</th>
      <td>S_1</td>
      <td>C_1</td>
      <td>M</td>
      <td>street_2</td>
      <td>186</td>
      <td>82</td>
      <td>87.2</td>
      <td>B+</td>
    </tr>
    <tr>
      <th>1104</th>
      <td>S_1</td>
      <td>C_1</td>
      <td>F</td>
      <td>street_2</td>
      <td>167</td>
      <td>81</td>
      <td>80.4</td>
      <td>B-</td>
    </tr>
    <tr>
      <th>1105</th>
      <td>S_1</td>
      <td>C_1</td>
      <td>F</td>
      <td>street_4</td>
      <td>159</td>
      <td>64</td>
      <td>84.8</td>
      <td>B+</td>
    </tr>
  </tbody>
</table>
</div>



#### （b）根据某几列分组


```python
grouped_mul = df.groupby(['School','Class'])
grouped_mul.get_group(('S_2','C_4'))
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Class</th>
      <th>Gender</th>
      <th>Address</th>
      <th>Height</th>
      <th>Weight</th>
      <th>Math</th>
      <th>Physics</th>
    </tr>
    <tr>
      <th>ID</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2401</th>
      <td>S_2</td>
      <td>C_4</td>
      <td>F</td>
      <td>street_2</td>
      <td>192</td>
      <td>62</td>
      <td>45.3</td>
      <td>A</td>
    </tr>
    <tr>
      <th>2402</th>
      <td>S_2</td>
      <td>C_4</td>
      <td>M</td>
      <td>street_7</td>
      <td>166</td>
      <td>82</td>
      <td>48.7</td>
      <td>B</td>
    </tr>
    <tr>
      <th>2403</th>
      <td>S_2</td>
      <td>C_4</td>
      <td>F</td>
      <td>street_6</td>
      <td>158</td>
      <td>60</td>
      <td>59.7</td>
      <td>B+</td>
    </tr>
    <tr>
      <th>2404</th>
      <td>S_2</td>
      <td>C_4</td>
      <td>F</td>
      <td>street_2</td>
      <td>160</td>
      <td>84</td>
      <td>67.7</td>
      <td>B</td>
    </tr>
    <tr>
      <th>2405</th>
      <td>S_2</td>
      <td>C_4</td>
      <td>F</td>
      <td>street_6</td>
      <td>193</td>
      <td>54</td>
      <td>47.6</td>
      <td>B</td>
    </tr>
  </tbody>
</table>
</div>



#### （c）组容量与组数


```python
grouped_single.size()
```




    School
    S_1    15
    S_2    20
    dtype: int64




```python
grouped_mul.size()
```




    School  Class
    S_1     C_1      5
            C_2      5
            C_3      5
    S_2     C_1      5
            C_2      5
            C_3      5
            C_4      5
    dtype: int64




```python
grouped_single.ngroups
```




    2




```python
grouped_mul.ngroups
```




    7



#### （d）组的遍历


```python
for name,group in grouped_single:
    print(name)
    display(group.head())
```

    S_1



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Class</th>
      <th>Gender</th>
      <th>Address</th>
      <th>Height</th>
      <th>Weight</th>
      <th>Math</th>
      <th>Physics</th>
    </tr>
    <tr>
      <th>ID</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1101</th>
      <td>S_1</td>
      <td>C_1</td>
      <td>M</td>
      <td>street_1</td>
      <td>173</td>
      <td>63</td>
      <td>34.0</td>
      <td>A+</td>
    </tr>
    <tr>
      <th>1102</th>
      <td>S_1</td>
      <td>C_1</td>
      <td>F</td>
      <td>street_2</td>
      <td>192</td>
      <td>73</td>
      <td>32.5</td>
      <td>B+</td>
    </tr>
    <tr>
      <th>1103</th>
      <td>S_1</td>
      <td>C_1</td>
      <td>M</td>
      <td>street_2</td>
      <td>186</td>
      <td>82</td>
      <td>87.2</td>
      <td>B+</td>
    </tr>
    <tr>
      <th>1104</th>
      <td>S_1</td>
      <td>C_1</td>
      <td>F</td>
      <td>street_2</td>
      <td>167</td>
      <td>81</td>
      <td>80.4</td>
      <td>B-</td>
    </tr>
    <tr>
      <th>1105</th>
      <td>S_1</td>
      <td>C_1</td>
      <td>F</td>
      <td>street_4</td>
      <td>159</td>
      <td>64</td>
      <td>84.8</td>
      <td>B+</td>
    </tr>
  </tbody>
</table>
</div>


    S_2



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Class</th>
      <th>Gender</th>
      <th>Address</th>
      <th>Height</th>
      <th>Weight</th>
      <th>Math</th>
      <th>Physics</th>
    </tr>
    <tr>
      <th>ID</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2101</th>
      <td>S_2</td>
      <td>C_1</td>
      <td>M</td>
      <td>street_7</td>
      <td>174</td>
      <td>84</td>
      <td>83.3</td>
      <td>C</td>
    </tr>
    <tr>
      <th>2102</th>
      <td>S_2</td>
      <td>C_1</td>
      <td>F</td>
      <td>street_6</td>
      <td>161</td>
      <td>61</td>
      <td>50.6</td>
      <td>B+</td>
    </tr>
    <tr>
      <th>2103</th>
      <td>S_2</td>
      <td>C_1</td>
      <td>M</td>
      <td>street_4</td>
      <td>157</td>
      <td>61</td>
      <td>52.5</td>
      <td>B-</td>
    </tr>
    <tr>
      <th>2104</th>
      <td>S_2</td>
      <td>C_1</td>
      <td>F</td>
      <td>street_5</td>
      <td>159</td>
      <td>97</td>
      <td>72.2</td>
      <td>B+</td>
    </tr>
    <tr>
      <th>2105</th>
      <td>S_2</td>
      <td>C_1</td>
      <td>M</td>
      <td>street_4</td>
      <td>170</td>
      <td>81</td>
      <td>34.2</td>
      <td>A</td>
    </tr>
  </tbody>
</table>
</div>


#### （e）level参数（用于多级索引）和axis参数


```python
df.set_index(['Gender','School']).groupby(level=1,axis=0).get_group('S_1').head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Class</th>
      <th>Address</th>
      <th>Height</th>
      <th>Weight</th>
      <th>Math</th>
      <th>Physics</th>
    </tr>
    <tr>
      <th>Gender</th>
      <th>School</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>M</th>
      <th>S_1</th>
      <td>C_1</td>
      <td>street_1</td>
      <td>173</td>
      <td>63</td>
      <td>34.0</td>
      <td>A+</td>
    </tr>
    <tr>
      <th>F</th>
      <th>S_1</th>
      <td>C_1</td>
      <td>street_2</td>
      <td>192</td>
      <td>73</td>
      <td>32.5</td>
      <td>B+</td>
    </tr>
    <tr>
      <th>M</th>
      <th>S_1</th>
      <td>C_1</td>
      <td>street_2</td>
      <td>186</td>
      <td>82</td>
      <td>87.2</td>
      <td>B+</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">F</th>
      <th>S_1</th>
      <td>C_1</td>
      <td>street_2</td>
      <td>167</td>
      <td>81</td>
      <td>80.4</td>
      <td>B-</td>
    </tr>
    <tr>
      <th>S_1</th>
      <td>C_1</td>
      <td>street_4</td>
      <td>159</td>
      <td>64</td>
      <td>84.8</td>
      <td>B+</td>
    </tr>
  </tbody>
</table>
</div>



### 2. groupby对象的特点
#### （a）查看所有可调用的方法
#### 由此可见，groupby对象可以使用相当多的函数，灵活程度很高


```python
print([attr for attr in dir(grouped_single) if not attr.startswith('_')])
```

    ['Address', 'Class', 'Gender', 'Height', 'Math', 'Physics', 'School', 'Weight', 'agg', 'aggregate', 'all', 'any', 'apply', 'backfill', 'bfill', 'boxplot', 'corr', 'corrwith', 'count', 'cov', 'cumcount', 'cummax', 'cummin', 'cumprod', 'cumsum', 'describe', 'diff', 'dtypes', 'expanding', 'ffill', 'fillna', 'filter', 'first', 'get_group', 'groups', 'head', 'hist', 'idxmax', 'idxmin', 'indices', 'last', 'mad', 'max', 'mean', 'median', 'min', 'ndim', 'ngroup', 'ngroups', 'nth', 'nunique', 'ohlc', 'pad', 'pct_change', 'pipe', 'plot', 'prod', 'quantile', 'rank', 'resample', 'rolling', 'sem', 'shift', 'size', 'skew', 'std', 'sum', 'tail', 'take', 'transform', 'tshift', 'var']


#### （b）分组对象的head和first
#### 对分组对象使用head函数，返回的是每个组的前几行，而不是数据集前几行


```python
grouped_single.head(2)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Class</th>
      <th>Gender</th>
      <th>Address</th>
      <th>Height</th>
      <th>Weight</th>
      <th>Math</th>
      <th>Physics</th>
    </tr>
    <tr>
      <th>ID</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1101</th>
      <td>S_1</td>
      <td>C_1</td>
      <td>M</td>
      <td>street_1</td>
      <td>173</td>
      <td>63</td>
      <td>34.0</td>
      <td>A+</td>
    </tr>
    <tr>
      <th>1102</th>
      <td>S_1</td>
      <td>C_1</td>
      <td>F</td>
      <td>street_2</td>
      <td>192</td>
      <td>73</td>
      <td>32.5</td>
      <td>B+</td>
    </tr>
    <tr>
      <th>2101</th>
      <td>S_2</td>
      <td>C_1</td>
      <td>M</td>
      <td>street_7</td>
      <td>174</td>
      <td>84</td>
      <td>83.3</td>
      <td>C</td>
    </tr>
    <tr>
      <th>2102</th>
      <td>S_2</td>
      <td>C_1</td>
      <td>F</td>
      <td>street_6</td>
      <td>161</td>
      <td>61</td>
      <td>50.6</td>
      <td>B+</td>
    </tr>
  </tbody>
</table>
</div>



#### first显示的是以分组为索引的每组的第一个分组信息


```python
grouped_single.first()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Class</th>
      <th>Gender</th>
      <th>Address</th>
      <th>Height</th>
      <th>Weight</th>
      <th>Math</th>
      <th>Physics</th>
    </tr>
    <tr>
      <th>School</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>S_1</th>
      <td>C_1</td>
      <td>M</td>
      <td>street_1</td>
      <td>173</td>
      <td>63</td>
      <td>34.0</td>
      <td>A+</td>
    </tr>
    <tr>
      <th>S_2</th>
      <td>C_1</td>
      <td>M</td>
      <td>street_7</td>
      <td>174</td>
      <td>84</td>
      <td>83.3</td>
      <td>C</td>
    </tr>
  </tbody>
</table>
</div>



#### （c）分组依据
#### 对于groupby函数而言，分组的依据是非常自由的，只要是与数据框长度相同的列表即可，同时支持函数型分组


```python
df.groupby(np.random.choice(['a','b','c'],df.shape[0])).get_group('a').head()
#相当于将np.random.choice(['a','b','c'],df.shape[0])当做新的一列进行分组
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Class</th>
      <th>Gender</th>
      <th>Address</th>
      <th>Height</th>
      <th>Weight</th>
      <th>Math</th>
      <th>Physics</th>
    </tr>
    <tr>
      <th>ID</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1101</th>
      <td>S_1</td>
      <td>C_1</td>
      <td>M</td>
      <td>street_1</td>
      <td>173</td>
      <td>63</td>
      <td>34.0</td>
      <td>A+</td>
    </tr>
    <tr>
      <th>1201</th>
      <td>S_1</td>
      <td>C_2</td>
      <td>M</td>
      <td>street_5</td>
      <td>188</td>
      <td>68</td>
      <td>97.0</td>
      <td>A-</td>
    </tr>
    <tr>
      <th>1301</th>
      <td>S_1</td>
      <td>C_3</td>
      <td>M</td>
      <td>street_4</td>
      <td>161</td>
      <td>68</td>
      <td>31.5</td>
      <td>B+</td>
    </tr>
    <tr>
      <th>1303</th>
      <td>S_1</td>
      <td>C_3</td>
      <td>M</td>
      <td>street_7</td>
      <td>188</td>
      <td>82</td>
      <td>49.7</td>
      <td>B</td>
    </tr>
    <tr>
      <th>1305</th>
      <td>S_1</td>
      <td>C_3</td>
      <td>F</td>
      <td>street_5</td>
      <td>187</td>
      <td>69</td>
      <td>61.7</td>
      <td>B-</td>
    </tr>
  </tbody>
</table>
</div>



#### 从原理上说，我们可以看到利用函数时，传入的对象就是索引，因此根据这一特性可以做一些复杂的操作


```python
df[:5].groupby(lambda x:print(x)).head(0)
```

    1101
    1102
    1103
    1104
    1105





<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Class</th>
      <th>Gender</th>
      <th>Address</th>
      <th>Height</th>
      <th>Weight</th>
      <th>Math</th>
      <th>Physics</th>
    </tr>
    <tr>
      <th>ID</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
  </tbody>
</table>
</div>



#### 根据奇偶行分组


```python
df.groupby(lambda x:'奇数行' if not df.index.get_loc(x)%2==1 else '偶数行').groups
```




    {'偶数行': Int64Index([1102, 1104, 1201, 1203, 1205, 1302, 1304, 2101, 2103, 2105, 2202,
                 2204, 2301, 2303, 2305, 2402, 2404],
                dtype='int64', name='ID'),
     '奇数行': Int64Index([1101, 1103, 1105, 1202, 1204, 1301, 1303, 1305, 2102, 2104, 2201,
                 2203, 2205, 2302, 2304, 2401, 2403, 2405],
                dtype='int64', name='ID')}



#### 如果是多层索引，那么lambda表达式中的输入就是元组，下面实现的功能为查看两所学校中男女生分别均分是否及格
#### 注意：此处只是演示groupby的用法，实际操作不会这样写


```python
math_score = df.set_index(['Gender','School'])['Math'].sort_index()
grouped_score = df.set_index(['Gender','School']).sort_index().\
            groupby(lambda x:(x,'均分及格' if math_score[x].mean()>=60 else '均分不及格'))
for name,_ in grouped_score:print(name)
```

    (('F', 'S_1'), '均分及格')
    (('F', 'S_2'), '均分及格')
    (('M', 'S_1'), '均分及格')
    (('M', 'S_2'), '均分不及格')


#### （d）groupby的[]操作
#### 可以用[]选出groupby对象的某个或者某几个列，上面的均分比较可以如下简洁地写出：


```python
df.groupby(['Gender','School'])['Math'].mean()>=60
```




    Gender  School
    F       S_1        True
            S_2        True
    M       S_1        True
            S_2       False
    Name: Math, dtype: bool



#### 用列表可选出多个属性列：


```python
df.groupby(['Gender','School'])[['Math','Height']].mean()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Math</th>
      <th>Height</th>
    </tr>
    <tr>
      <th>Gender</th>
      <th>School</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">F</th>
      <th>S_1</th>
      <td>64.100000</td>
      <td>173.125000</td>
    </tr>
    <tr>
      <th>S_2</th>
      <td>66.427273</td>
      <td>173.727273</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">M</th>
      <th>S_1</th>
      <td>63.342857</td>
      <td>178.714286</td>
    </tr>
    <tr>
      <th>S_2</th>
      <td>51.155556</td>
      <td>172.000000</td>
    </tr>
  </tbody>
</table>
</div>



#### （e）连续型变量分组
#### 例如利用cut函数对数学成绩分组：


```python
bins = [0,40,60,80,90,100]
cuts = pd.cut(df['Math'],bins=bins) #可选label添加自定义标签
df.groupby(cuts)['Math'].count()
```




    Math
    (0, 40]       7
    (40, 60]     10
    (60, 80]      9
    (80, 90]      7
    (90, 100]     2
    Name: Math, dtype: int64



## 三、聚合、过滤和变换
### 1. 聚合（Aggregation）
#### （a）常用聚合函数
#### 所谓聚合就是把一堆数，变成一个标量，因此mean/sum/size/count/std/var/sem/describe/first/last/nth/min/max都是聚合函数
#### 为了熟悉操作，不妨验证标准误sem函数，它的计算公式是：$\frac{组内标准差}{\sqrt{组容量}}$，下面进行验证：


```python
group_m = grouped_single['Math']
group_m.std().values/np.sqrt(group_m.count().values)== group_m.sem().values
```




    array([ True,  True])



#### （b）同时使用多个聚合函数


```python
group_m.agg(['sum','mean','std'])
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>sum</th>
      <th>mean</th>
      <th>std</th>
    </tr>
    <tr>
      <th>School</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>S_1</th>
      <td>956.2</td>
      <td>63.746667</td>
      <td>23.077474</td>
    </tr>
    <tr>
      <th>S_2</th>
      <td>1191.1</td>
      <td>59.555000</td>
      <td>17.589305</td>
    </tr>
  </tbody>
</table>
</div>



#### 利用元组进行重命名


```python
group_m.agg([('rename_sum','sum'),('rename_mean','mean')])
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>rename_sum</th>
      <th>rename_mean</th>
    </tr>
    <tr>
      <th>School</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>S_1</th>
      <td>956.2</td>
      <td>63.746667</td>
    </tr>
    <tr>
      <th>S_2</th>
      <td>1191.1</td>
      <td>59.555000</td>
    </tr>
  </tbody>
</table>
</div>



#### 指定哪些函数作用哪些列


```python
grouped_mul.agg({'Math':['mean','max'],'Height':'var'})
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th colspan="2" halign="left">Math</th>
      <th>Height</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>mean</th>
      <th>max</th>
      <th>var</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Class</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3" valign="top">S_1</th>
      <th>C_1</th>
      <td>63.78</td>
      <td>87.2</td>
      <td>183.3</td>
    </tr>
    <tr>
      <th>C_2</th>
      <td>64.30</td>
      <td>97.0</td>
      <td>132.8</td>
    </tr>
    <tr>
      <th>C_3</th>
      <td>63.16</td>
      <td>87.7</td>
      <td>179.2</td>
    </tr>
    <tr>
      <th rowspan="4" valign="top">S_2</th>
      <th>C_1</th>
      <td>58.56</td>
      <td>83.3</td>
      <td>54.7</td>
    </tr>
    <tr>
      <th>C_2</th>
      <td>62.80</td>
      <td>85.4</td>
      <td>256.0</td>
    </tr>
    <tr>
      <th>C_3</th>
      <td>63.06</td>
      <td>95.5</td>
      <td>205.7</td>
    </tr>
    <tr>
      <th>C_4</th>
      <td>53.80</td>
      <td>67.7</td>
      <td>300.2</td>
    </tr>
  </tbody>
</table>
</div>



#### （c）使用自定义函数


```python
grouped_single['Math'].agg(lambda x:print(x.head(),'间隔'))
#可以发现，agg函数的传入是分组逐列进行的，有了这个特性就可以做许多事情
```

    Series([], Name: Math, dtype: float64) 间隔
    1101    34.0
    1102    32.5
    1103    87.2
    1104    80.4
    1105    84.8
    Name: Math, dtype: float64 间隔
    2101    83.3
    2102    50.6
    2103    52.5
    2104    72.2
    2105    34.2
    Name: Math, dtype: float64 间隔





    School
    S_1    None
    S_2    None
    Name: Math, dtype: object



#### 官方没有提供极差计算的函数，但通过agg可以容易地实现组内极差计算


```python
grouped_single['Math'].agg(lambda x:x.max()-x.min())
```




    School
    S_1    65.5
    S_2    62.8
    Name: Math, dtype: float64



#### （d）利用NamedAgg函数进行多个聚合
#### 注意：不支持lambda函数，但是可以使用外置的def函数


```python
def R1(x):
    return x.max()-x.min()
def R2(x):
    return x.max()-x.median()
grouped_single['Math'].agg(min_score1=pd.NamedAgg(column='col1', aggfunc=R1),
                           max_score1=pd.NamedAgg(column='col2', aggfunc='max'),
                           range_score2=pd.NamedAgg(column='col3', aggfunc=R2)).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>min_score1</th>
      <th>max_score1</th>
      <th>range_score2</th>
    </tr>
    <tr>
      <th>School</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>S_1</th>
      <td>65.5</td>
      <td>97.0</td>
      <td>33.5</td>
    </tr>
    <tr>
      <th>S_2</th>
      <td>62.8</td>
      <td>95.5</td>
      <td>39.4</td>
    </tr>
  </tbody>
</table>
</div>



#### （e）带参数的聚合函数
#### 判断是否组内数学分数至少有一个值在50-52之间：


```python
def f(s,low,high):
    return s.between(low,high).max()
grouped_single['Math'].agg(f,50,52)
```




    School
    S_1    False
    S_2     True
    Name: Math, dtype: bool



#### 如果需要使用多个函数，并且其中至少有一个带参数，则使用wrap技巧：


```python
def f_test(s,low,high):
    return s.between(low,high).max()
def agg_f(f_mul,name,*args,**kwargs):
    def wrapper(x):
        return f_mul(x,*args,**kwargs)
    wrapper.__name__ = name
    return wrapper
new_f = agg_f(f_test,'at_least_one_in_50_52',50,52)
grouped_single['Math'].agg([new_f,'mean']).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>at_least_one_in_50_52</th>
      <th>mean</th>
    </tr>
    <tr>
      <th>School</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>S_1</th>
      <td>False</td>
      <td>63.746667</td>
    </tr>
    <tr>
      <th>S_2</th>
      <td>True</td>
      <td>59.555000</td>
    </tr>
  </tbody>
</table>
</div>



### 2. 过滤（Filteration）
#### filter函数是用来筛选某些组的（务必记住结果是组的全体），因此传入的值应当是布尔标量


```python
grouped_single[['Math','Physics']].filter(lambda x:(x['Math']>32).all()).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Math</th>
      <th>Physics</th>
    </tr>
    <tr>
      <th>ID</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2101</th>
      <td>83.3</td>
      <td>C</td>
    </tr>
    <tr>
      <th>2102</th>
      <td>50.6</td>
      <td>B+</td>
    </tr>
    <tr>
      <th>2103</th>
      <td>52.5</td>
      <td>B-</td>
    </tr>
    <tr>
      <th>2104</th>
      <td>72.2</td>
      <td>B+</td>
    </tr>
    <tr>
      <th>2105</th>
      <td>34.2</td>
      <td>A</td>
    </tr>
  </tbody>
</table>
</div>



### 3. 变换（Transformation）
#### （a）传入对象
#### transform函数中传入的对象是组内的列，并且返回值需要与列长完全一致


```python
grouped_single[['Math','Height']].transform(lambda x:x-x.min()).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Math</th>
      <th>Height</th>
    </tr>
    <tr>
      <th>ID</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1101</th>
      <td>2.5</td>
      <td>14</td>
    </tr>
    <tr>
      <th>1102</th>
      <td>1.0</td>
      <td>33</td>
    </tr>
    <tr>
      <th>1103</th>
      <td>55.7</td>
      <td>27</td>
    </tr>
    <tr>
      <th>1104</th>
      <td>48.9</td>
      <td>8</td>
    </tr>
    <tr>
      <th>1105</th>
      <td>53.3</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>



#### 如果返回了标量值，那么组内的所有元素会被广播为这个值


```python
grouped_single[['Math','Height']].transform(lambda x:x.mean()).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Math</th>
      <th>Height</th>
    </tr>
    <tr>
      <th>ID</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1101</th>
      <td>63.746667</td>
      <td>175.733333</td>
    </tr>
    <tr>
      <th>1102</th>
      <td>63.746667</td>
      <td>175.733333</td>
    </tr>
    <tr>
      <th>1103</th>
      <td>63.746667</td>
      <td>175.733333</td>
    </tr>
    <tr>
      <th>1104</th>
      <td>63.746667</td>
      <td>175.733333</td>
    </tr>
    <tr>
      <th>1105</th>
      <td>63.746667</td>
      <td>175.733333</td>
    </tr>
  </tbody>
</table>
</div>



#### （b）利用变换方法进行组内标准化


```python
grouped_single[['Math','Height']].transform(lambda x:(x-x.mean())/x.std()).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Math</th>
      <th>Height</th>
    </tr>
    <tr>
      <th>ID</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1101</th>
      <td>-1.288991</td>
      <td>-0.214991</td>
    </tr>
    <tr>
      <th>1102</th>
      <td>-1.353990</td>
      <td>1.279460</td>
    </tr>
    <tr>
      <th>1103</th>
      <td>1.016287</td>
      <td>0.807528</td>
    </tr>
    <tr>
      <th>1104</th>
      <td>0.721627</td>
      <td>-0.686923</td>
    </tr>
    <tr>
      <th>1105</th>
      <td>0.912289</td>
      <td>-1.316166</td>
    </tr>
  </tbody>
</table>
</div>



#### （c）利用变换方法进行组内缺失值的均值填充


```python
df_nan = df[['Math','School']].copy().reset_index()
df_nan.loc[np.random.randint(0,df.shape[0],25),['Math']]=np.nan
df_nan.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>ID</th>
      <th>Math</th>
      <th>School</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1101</td>
      <td>NaN</td>
      <td>S_1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1102</td>
      <td>32.5</td>
      <td>S_1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1103</td>
      <td>NaN</td>
      <td>S_1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1104</td>
      <td>NaN</td>
      <td>S_1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1105</td>
      <td>84.8</td>
      <td>S_1</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_nan.groupby('School').transform(lambda x: x.fillna(x.mean())).join(df.reset_index()['School']).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>ID</th>
      <th>Math</th>
      <th>School</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1101</td>
      <td>68.525</td>
      <td>S_1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1102</td>
      <td>32.500</td>
      <td>S_1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1103</td>
      <td>68.525</td>
      <td>S_1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1104</td>
      <td>68.525</td>
      <td>S_1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1105</td>
      <td>84.800</td>
      <td>S_1</td>
    </tr>
  </tbody>
</table>
</div>



## 四、apply函数

### 1. apply函数的灵活性
#### 可能在所有的分组函数中，apply是应用最为广泛的，这得益于它的灵活性：
#### 对于传入值而言，从下面的打印内容可以看到是以分组的表传入apply中：


```python
df.groupby('School').apply(lambda x:print(x.head(1)))
```

         School Class Gender   Address  Height  Weight  Math Physics
    ID                                                              
    1101    S_1   C_1      M  street_1     173      63  34.0      A+
         School Class Gender   Address  Height  Weight  Math Physics
    ID                                                              
    2101    S_2   C_1      M  street_7     174      84  83.3       C





<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
    </tr>
  </thead>
  <tbody>
  </tbody>
</table>
</div>



#### apply函数的灵活性很大程度来源于其返回值的多样性：
#### ① 标量返回值


```python
df[['School','Math','Height']].groupby('School').apply(lambda x:x.max())
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Math</th>
      <th>Height</th>
    </tr>
    <tr>
      <th>School</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>S_1</th>
      <td>S_1</td>
      <td>97.0</td>
      <td>195</td>
    </tr>
    <tr>
      <th>S_2</th>
      <td>S_2</td>
      <td>95.5</td>
      <td>194</td>
    </tr>
  </tbody>
</table>
</div>



#### ② 列表返回值


```python
df[['School','Math','Height']].groupby('School').apply(lambda x:x-x.min()).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Math</th>
      <th>Height</th>
    </tr>
    <tr>
      <th>ID</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1101</th>
      <td>2.5</td>
      <td>14.0</td>
    </tr>
    <tr>
      <th>1102</th>
      <td>1.0</td>
      <td>33.0</td>
    </tr>
    <tr>
      <th>1103</th>
      <td>55.7</td>
      <td>27.0</td>
    </tr>
    <tr>
      <th>1104</th>
      <td>48.9</td>
      <td>8.0</td>
    </tr>
    <tr>
      <th>1105</th>
      <td>53.3</td>
      <td>0.0</td>
    </tr>
  </tbody>
</table>
</div>



#### ③ 数据框返回值


```python
df[['School','Math','Height']].groupby('School')\
    .apply(lambda x:pd.DataFrame({'col1':x['Math']-x['Math'].max(),
                                  'col2':x['Math']-x['Math'].min(),
                                  'col3':x['Height']-x['Height'].max(),
                                  'col4':x['Height']-x['Height'].min()})).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>col1</th>
      <th>col2</th>
      <th>col3</th>
      <th>col4</th>
    </tr>
    <tr>
      <th>ID</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1101</th>
      <td>-63.0</td>
      <td>2.5</td>
      <td>-22</td>
      <td>14</td>
    </tr>
    <tr>
      <th>1102</th>
      <td>-64.5</td>
      <td>1.0</td>
      <td>-3</td>
      <td>33</td>
    </tr>
    <tr>
      <th>1103</th>
      <td>-9.8</td>
      <td>55.7</td>
      <td>-9</td>
      <td>27</td>
    </tr>
    <tr>
      <th>1104</th>
      <td>-16.6</td>
      <td>48.9</td>
      <td>-28</td>
      <td>8</td>
    </tr>
    <tr>
      <th>1105</th>
      <td>-12.2</td>
      <td>53.3</td>
      <td>-36</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>



### 2. 用apply同时统计多个指标
#### 此处可以借助OrderedDict工具进行快捷的统计：


```python
from collections import OrderedDict
def f(df):
    data = OrderedDict()
    data['M_sum'] = df['Math'].sum()
    data['W_var'] = df['Weight'].var()
    data['H_mean'] = df['Height'].mean()
    return pd.Series(data)
grouped_single.apply(f)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>M_sum</th>
      <th>W_var</th>
      <th>H_mean</th>
    </tr>
    <tr>
      <th>School</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>S_1</th>
      <td>956.2</td>
      <td>117.428571</td>
      <td>175.733333</td>
    </tr>
    <tr>
      <th>S_2</th>
      <td>1191.1</td>
      <td>181.081579</td>
      <td>172.950000</td>
    </tr>
  </tbody>
</table>
</div>



## 五、问题与练习

### 1. 问题

#### 【问题一】 什么是fillna的前向/后向填充，如何实现？

#### 【问题二】 下面的代码实现了什么功能？请仿照设计一个它的groupby版本。


```python
s = pd.Series ([0, 1, 1, 0, 1, 1, 1, 0])
s1 = s.cumsum()
result = s.mul(s1).diff().where(lambda x: x < 0).ffill().add(s1,fill_value =0)
```

#### 【问题三】 如何计算组内0.25分位数与0.75分位数？要求显示在同一张表上。
#### 【问题四】 既然索引已经能够选出某些符合条件的子集，那么filter函数的设计有什么意义？
#### 【问题五】 整合、变换、过滤三者在输入输出和功能上有何异同？
#### 【问题六】 在带参数的多函数聚合时，有办法能够绕过wrap技巧实现同样功能吗？

### 2. 练习
#### 【练习一】： 现有一份关于diamonds的数据集，列分别记录了克拉数、颜色、开采深度、价格，请解决下列问题：


```python
pd.read_csv('data/Diamonds.csv').head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>carat</th>
      <th>color</th>
      <th>depth</th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.23</td>
      <td>E</td>
      <td>61.5</td>
      <td>326</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.21</td>
      <td>E</td>
      <td>59.8</td>
      <td>326</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.23</td>
      <td>E</td>
      <td>56.9</td>
      <td>327</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.29</td>
      <td>I</td>
      <td>62.4</td>
      <td>334</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.31</td>
      <td>J</td>
      <td>63.3</td>
      <td>335</td>
    </tr>
  </tbody>
</table>
</div>



#### (a) 在所有重量超过1克拉的钻石中，价格的极差是多少？
#### (b) 若以开采深度的0.2\0.4\0.6\0.8分位数为分组依据，每一组中钻石颜色最多的是哪一种？该种颜色是组内平均而言单位重量最贵的吗？
#### (c) 以重量分组(0-0.5,0.5-1,1-1.5,1.5-2,2+)，按递增的深度为索引排序，求每组中连续的严格递增价格序列长度的最大值。
#### (d) 请按颜色分组，分别计算价格关于克拉数的回归系数。（单变量的简单线性回归，并只使用Pandas和Numpy完成）

#### 【练习二】：有一份关于美国10年至17年的非法药物数据集，列分别记录了年份、州（5个）、县、药物类型、报告数量，请解决下列问题：


```python
pd.read_csv('data/Drugs.csv').head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>YYYY</th>
      <th>State</th>
      <th>COUNTY</th>
      <th>SubstanceName</th>
      <th>DrugReports</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2010</td>
      <td>VA</td>
      <td>ACCOMACK</td>
      <td>Propoxyphene</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2010</td>
      <td>OH</td>
      <td>ADAMS</td>
      <td>Morphine</td>
      <td>9</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2010</td>
      <td>PA</td>
      <td>ADAMS</td>
      <td>Methadone</td>
      <td>2</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2010</td>
      <td>VA</td>
      <td>ALEXANDRIA CITY</td>
      <td>Heroin</td>
      <td>5</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2010</td>
      <td>PA</td>
      <td>ALLEGHENY</td>
      <td>Hydromorphone</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
</div>



#### (a) 按照年份统计，哪个县的报告数量最多？这个县所属的州在当年也是报告数最多的吗？
#### (b) 从14年到15年，Heroin的数量增加最多的是哪一个州？它在这个州是所有药物中增幅最大的吗？若不是，请找出符合该条件的药物。
